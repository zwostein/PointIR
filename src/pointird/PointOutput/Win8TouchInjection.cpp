/*
 * Copyright (C) 2014 Tobias Himmer <provisorisch@online.de>
 *
 * This file is part of PointIR.
 *
 * PointIR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PointIR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PointIR.  If not, see <http://www.gnu.org/licenses/>.
 */


#include "Win8TouchInjection.hpp"
#include "../exceptions.hpp"
#include "../Tracker.hpp"

#include <PointIR/PointArray.h>

#include <iostream>
#include <vector>

#include <windows.h>

#include "Win8TouchInjection/touchinjection_sdk80.h"


//TODO: limit the number of ids generated by the tracker to the maximum allowed number of touch points

// Windows specific constant indicating the maximum number of touch points the
// inject api will allow. This also sets the maximum numerical value for touch
// ids we can use when injecting touch points on Windows.
#define TOUCH_INJECT_MAX_POINTS 256


using namespace PointOutput;


class Win8TouchInjection::Impl
{
public:
	InitializeTouchInjectionPtr InitializeTouchInjection = nullptr;
	InjectTouchInputPtr InjectTouchInput = nullptr;

	PointIR::PointArray previousPoints;
	std::vector< int > previousIDs;
	std::vector< int > currentIDs;
	Tracker tracker;
};


Win8TouchInjection::Win8TouchInjection() :
	pImpl( new Impl )
{
	HMODULE hMod = LoadLibraryW( L"user32.dll" );
	if( !hMod )
		throw RUNTIME_ERROR( "Could not load user32.dll" );

	// initialize function pointers
	this->pImpl->InitializeTouchInjection = (InitializeTouchInjectionPtr)GetProcAddress( hMod, "InitializeTouchInjection" );
	if( !this->pImpl->InitializeTouchInjection )
		throw RUNTIME_ERROR( "Touch Injection API unavailable! (InitializeTouchInjection not found in user32.dll)" );
	this->pImpl->InjectTouchInput = (InjectTouchInputPtr)GetProcAddress( hMod, "InjectTouchInput" );
	if( !this->pImpl->InjectTouchInput )
		throw RUNTIME_ERROR("Touch Injection API unavailable! (InjectTouchInput not found in user32.dll)");

	if( !this->pImpl->InitializeTouchInjection( TOUCH_INJECT_MAX_POINTS, TOUCH_FEEDBACK_DEFAULT ) )
		throw RUNTIME_ERROR( "InitializeTouchInjection failure. GetLastError=" + std::to_string(GetLastError()) );
}


Win8TouchInjection::~Win8TouchInjection()
{
}


static void clampToScreen( POINT & p, int screenWidth, int screenHeight )
{
	if( p.x < 0 )
		p.x = 0;
	else if( p.x >= screenWidth )
		p.x = screenWidth-1;

	if( p.y < 0 )
		p.y = 0;
	else if( p.y >= screenHeight )
		p.y = screenHeight-1;
}



void Win8TouchInjection::outputPoints( const PointIR::PointArray & currentPoints )
{
	std::vector< int > & mapToPrevious = this->pImpl->tracker.assignIDs( this->pImpl->previousPoints, this->pImpl->previousIDs, currentPoints, this->pImpl->currentIDs );

	int screenWidth = GetSystemMetrics( SM_CXSCREEN );
	int screenHeight = GetSystemMetrics( SM_CYSCREEN );

	std::vector< POINTER_TOUCH_INFO > infos;
	infos.reserve( currentPoints.size() );

	// remove points not found in the current frame
	for( unsigned int i = 0; i < this->pImpl->previousPoints.size(); i++ )
	{
		bool disappeared = true;
		for( unsigned int j = 0; j < mapToPrevious.size(); j++ )
		{
			if( (long int)mapToPrevious[j] == (long int)i )
			{
				disappeared = false;
				break;
			}
		}
		if( !disappeared )
			continue;

		POINTER_TOUCH_INFO info = {0};
		info.touchFlags = TOUCH_FLAG_NONE;
		info.touchMask = TOUCH_MASK_NONE;
		info.pointerInfo.pointerFlags = POINTER_FLAG_UP;
		info.pointerInfo.pointerType = PT_TOUCH;
		info.pointerInfo.pointerId = this->pImpl->previousIDs[i];
		info.pointerInfo.ptPixelLocation.x = this->pImpl->previousPoints[i].x * screenWidth;
		info.pointerInfo.ptPixelLocation.y = this->pImpl->previousPoints[i].y * screenHeight;
		clampToScreen( info.pointerInfo.ptPixelLocation, screenWidth, screenHeight );

		infos.push_back( info );
//		std::cerr << "Win8TouchInjection: Removed " << info.pointerInfo.pointerId << "\n";
	}

	// handle new and updated points - if any
	if( currentPoints.size() )
	{
		for( unsigned int i = 0; i < currentPoints.size(); i++ )
		{
			POINTER_TOUCH_INFO info = {0};
			info.touchFlags = TOUCH_FLAG_NONE;
			info.touchMask = TOUCH_MASK_NONE;

			info.pointerInfo.pointerFlags = POINTER_FLAG_INRANGE | POINTER_FLAG_INCONTACT;
			if( mapToPrevious[i] < 0 ) // not in previous frame - has to be new
				info.pointerInfo.pointerFlags |= POINTER_FLAG_DOWN;
			else // normal update - point just moved
				info.pointerInfo.pointerFlags |= POINTER_FLAG_UPDATE;

			info.pointerInfo.pointerType = PT_TOUCH;
			info.pointerInfo.pointerId = this->pImpl->currentIDs[i];
			info.pointerInfo.ptPixelLocation.x = currentPoints[i].x * screenWidth;;
			info.pointerInfo.ptPixelLocation.y = currentPoints[i].y * screenHeight;
			clampToScreen( info.pointerInfo.ptPixelLocation, screenWidth, screenHeight );

			infos.push_back( info );
//			std::cerr << "Win8TouchInjection: " << ((info.pointerInfo.pointerFlags&POINTER_FLAG_UPDATE)?"Updated ":"Added ") << info.pointerInfo.pointerId << "\n";
		}
	}

	if( !infos.empty() )
	{
		if( !this->pImpl->InjectTouchInput( infos.size(), infos.data() ) )
			std::cerr << "Win8TouchInjection: InjectTouchInput failed with error " << GetLastError() << "\n";
	}

	this->pImpl->previousPoints = currentPoints;
	this->pImpl->previousIDs = this->pImpl->currentIDs;
}
